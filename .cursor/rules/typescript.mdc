---
alwaysApply: true
---

1. Do NOT use suffixes like "Type", "Definition", or "Model".
   Example (❌): UserType, UserDefinition, UserModel
   Example (✅): User

2. Use singular PascalCase names for core domain entities.
   Example: User, Appointment, Doctor, Invoice

3. For input payloads, use the suffix "Input".
   Example: CreateUserInput, UpdateAppointmentInput

4. For API output shapes, use the suffix "Response" or a semantic name.
   Example: UserResponse, AppointmentListItem

5. For enums, use clear domain-based naming.
   Example: UserRole, AppointmentStatus

6. For database-only representations, use the suffix "Entity" (backend only).
   Example: UserEntity

7. When using Zod:
   - Schema must be named "<EntityName>Schema"
   - The inferred type must be named "<EntityName>"

   Example:
   export const UserSchema = z.object({...});
   export type User = z.infer<typeof UserSchema>;

8. Avoid ambiguous names.
   Do NOT use: Data, Object, Item, Definition, Model
   Prefer domain-specific names.

9. All types must reflect domain meaning, not technical implementation details.

────────────────────────
TYPE SAFETY RULES
────────────────────────

10. NEVER use TypeScript type assertions using `as`.
    ❌ value as User
    ❌ {} as SomeType
    ❌ foo as unknown as Something

11. Do NOT bypass type safety using `any` or `unknown` unless absolutely unavoidable.

12. If a type mismatch occurs:
    - Fix the type definition.
    - Refactor the code.
    - Use proper type guards.
    - Use Zod parsing or schema validation.
    - Use narrowing instead of assertion.

13. If narrowing is needed, prefer:
    - Type guards
    - `in` operator
    - Discriminated unions
    - Zod `.parse()` or `.safeParse()`

14. Never silence TypeScript errors with assertions. The type system must be trusted and preserved.

All generated code must maintain strict type safety.
